.model small 
.stack 
.data                  

file_1     db 'file1.txt',0     		; 1-ый исходный файл для сравнения

file_2     db 'file2.txt',0    			; 2-ый исходный файл для сравнения

file_result      db 'result.txt',0   	; Файл вывода р-тата  сравнения            

error      db 'Error!',13,10,'$' 		; Сообщение об ошибке при работе с файлами       

buffer_1     db 512 dup(0)     
										; Память под 2 буфера
buffer_2     db 512 dup(0)     
        
handle     dw 0   						; Дискриптор файла

sizeFile1        db 1 dup(?)
sizeFile2        db 1 dup(?)
str2        db 100 dup(?), '$'
str1        db 100 dup(?), '$'
len         dw 0 
rez         db 20 dup(?)

.code

jmp begin 

begin:
    mov ax, @data
    mov ds, ax
    mov es, ax				; ds и es установили на текущий сегмент данных
    call initFile1			; вызываем ф-цию обработки 1ого файла
    call initFile2 	 		; вызываем ф-цию обработки 2ого файла         
    call korrel
nn: call openFileResult
    jmp exit

;---------------------------------	
; Обработка 1 файла
; Вход  DX - адрес файла Al = 0 (0- чтение, 1- запись, 2-чтение и запись)	
;---------------------------------	
initFile1:
    lea dx, file_1			; ф-ция 3Dh открывает файл
    call openFile 			; вызывает ф-цию открытия
    lea dx,buffer_1			; в dx адрес 1ого буфера
    call readFile 			; вызываем ф-цию чтения
    lea di,sizeFile1		; в dx адрес 1ого буфера
    stosw					; сохраняем р-тат подсчета в sizeFile1
    lea bx,buffer_1 		; в bx адрес 1ого буфера
    call buffToStr 			; вызов buffToStr
    call closeFile			; вызов ф-ции закрытия файла
    ret
	
;---------------------------------	
; Обработка 2 файла
; Вход  DX - адрес файла Al = 0 (0 - чтение, 1 - запись, 2 - чтение и запись)	
;---------------------------------	
initFile2:
    lea dx, file_2
    call openFile  
    lea dx,buffer_2
    call readFile
    lea di,sizeFile2
    stosw 
    lea bx,buffer_2 
    call buffToStr
    call closeFile
    ret 
    
;---------------------------------	
; Открытие файла
; Вход: BX - адрес файла
; Выход: AX - дескриптор файла
;---------------------------------		
openFile: 			
    mov ah,3Dh 		; функция открытия файла            
    xor al,al		; обнулили Al (открытие файла для чтения)
    int 21h 	
    ret 			; возврат к последнему call
    
;---------------------------------	
; Чтение файла
; Вход:  bx - дескриптор файла
;		 ah - 3Fh,
; 		 cx - кол-во считываемых байт
;		 dx - адрес куда поместить то, что прочитали
; Выход: Ax - кол-во действительно прочитанных байт
;---------------------------------	    
readFile: 		
    mov [handle],ax ; сохранили дескриптор в handle        
    mov bx,ax   	; дескриптор в bx            
    mov ah,3Fh                        
    mov cx,80  		; в cx кол-во байт, сколько нужно считать из файла           
    int 21h
     
    ret    			; возврат в call               
	
	
;---------------------------------	
; Добавление символа $ в конец строки
;---------------------------------	 	
buffToStr: 		
    add bx,ax 		 ; В AX количество прочитанных байтов              
    mov byte[bx],'$' ; Добавление символа '$'
    ret ; возврат
;------------------------------------
;подсчет корреляции по ф-ле http://www.inkcanon.com/image/img/img2.png
;------------------------------------
korrel:
    mov cx,0   		;обнуляем cx, cx - указатель перемещения по цепочке          
sum:
    xor ax,ax			; обнуляем ax
    xor bx,bx			; обнуляем bx
    lea si, buffer_1	; в si адрес 1ого буфера
    add si,cx 			; устанавливаем указатель для 1-ого буфера
    lodsb				; заносим значение цепочки в аккумулятор
    mov bx,ax			; заносим значение из ax в bx
    lea si, buffer_2	; в si адрес 2ого буфера
    add si,cx 			; устанавливаем указатель для 2-ого буфера
    add si,len  		; добавляем смещение
    lodsb 				; заносим значение цепочки в аккумулятор
    mul bl				; умножаем al на bl
    add dx,ax 			; р-тат умножение добавляем в dx
    xor ax,ax			; очищаем ax
    lodsb 				; заносим значение цепочки в аккумулятор
    inc cx    			; перемещаем указатель на следующий элемент буфера
    cmp ax, 0  			; проверка на окончание цепочки
    jne sum				; если цепочка не закончилась, то переходим в sum
    jmp del				; иначе - в del
	
;-------------------------------------------------------------------------
;Выполняем деление (смотри формулу)
;-------------------------------------------------------------------------
del:
	mov ax,dx			; заносим значение из dx в ax
	xor dx,dx			; очищаем dx
	div cx 				; выполняем деление dx:ax на cx (http://www.kolasc.net.ru/cdo/programmes/assembler/div.html)
	mov bx,ax			; заносим значение из ax в bx
	mov ax,dx			; заносим значение из dx в ax
	xor dx,dx			; очищаем dx
	mov dl, 10			; заносим в dl 10
	mul dx				; умножаем ax на dx
	xor dx,dx			; очищаем dx
	div cx				; делим dx:ax на cx
	call hexToASCII		; переходим в hexToASCII
	
;--------------------------------------------------------------------------
; Преобразование шестнадцатиричного числа в код ASCII 
;--------------------------------------------------------------------------
hexToASCII:
	mov dx,ax    		; заносим значение из ax в dx
	mov ax,bx			; заносим значение из bx в ax
	aam
	or ax, 3030h		;преобразование 16-ричного в ASCII
	mov bl,al 			
	mov al,ah 			;меняем местами ah и al
	mov ah, bl
	lea di, rez			; в si адрес rez (строки для р-та)
	stosw 				; заносим ax в rez
	xor bx,bx			; очищаем bx
	lea bx, rez
	add bx,2               
	mov byte[bx],'.'	; заносим "точку" в конец файла р-та
	mov ax, dx			; заносим значение из ax в dx
	aam
	or ax, 3030h		;преобразование 16-ричного в ASCII
	mov bl,al 
	mov al,ah 
	mov ah, bl			;меняем местами ah и al
	xor bx,bx			; очищаем bx
	lea bx, rez		
	add bx,3  
	mov byte[bx], ah	; заносим дробную часть после точки
	jmp nn				; переходим к ф-ции записи в файл

     
;---------------------------------	
; Отрыть файл для записи результата сравнения
;---------------------------------	     
openFileResult: 		
    mov ah,3Dh              
    mov al,1  			; al=1 режим для записи             
    lea dx, file_result
    int 21h     
    jnc printFileResult вызываем ф-цию записи в файл                  
    call error_msg 
	
;---------------------------------	
; Запись результата сравнения в файл
; Вход: bx - дескриптор файла в который будем записывать
;		dx - адрес буфера, содержащего записываемые данные
;		cx - число записываемых байт
;---------------------------------	    
printFileResult: 		  
    mov [handle],ax         
    mov bx,ax  
    mov ah, 40h  		; записываем в файл ф-цией 40h() 
    lea dx,rez 
    mov cx,4
    int 21h           
    jmp closeFile 		; вызывает ф-цию закрытия файла 
	
;---------------------------------	
; Закрытие файла
; Вход bx-дескриптор файла
;---------------------------------	 
closeFile: 				
    mov ah,3Eh              
    mov bx,[handle] 	; помещаем дескриптор в bx         
    int 21h
    xor dx,dx 			; "обнуляем" dx
    xor bx,bx 			; "обнуляем" bx
    ret 
	
;---------------------------------	
; Завершение программы  
;---------------------------------	 	
exit:  					  
    mov ah,8                
    int 21h                 
    mov ax,4C00h            
    int 21h    
	
;---------------------------------	
; Вывод сообщения об ошибке
;---------------------------------	  
error_msg:
    mov ah,9
    lea dx,error
    int 21h                 
    ret

